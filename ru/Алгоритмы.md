![[Pasted image 20241117204717.png]]
### Что такое временная сложность и как она измеряется?Объясните разницу между временем выполнения O(n), O(log n) и O(n^2).
https://habr.com/ru/articles/188010/
Временная сложность — это мера количества времени, необходимого алгоритму для выполнения в зависимости от размера входных данных. Она обычно выражается с использованием нотации "Большое O" (O-нотация), которая описывает предельное поведение функции, игнорируя константы и менее значимые члены. Например, если алгоритм выполняется за 3n + 5 операций, его временная сложность будет O(n).

Различные временные сложности описывают, как время выполнения алгоритма растет с увеличением размера входных данных. O(n) означает, что время выполнения линейно зависит от размера входа; O(log n) указывает на логарифмическое время, что часто встречается в бинарном поиске, где размер данных уменьшается вдвое на каждой итерации; O(n^2) обозначает квадратичное время, характерное для алгоритмов, таких как сортировка пузырьком, где каждая пара элементов сравнивается.

### Что такое сложность по пространству?
Сложность по пространству описывает количество памяти, необходимой алгоритму для выполнения, в зависимости от размера входных данных. Подобно временной сложности, она также может быть выражена в O-нотации. Например, если алгоритм использует фиксированное количество дополнительной памяти вне зависимости от размера входа, его пространственная сложность будет O(1). Если память требует хранения массива, размер которого пропорционален размеру входа, то сложность будет O(n).

Пространственная сложность важна при разработке алгоритмов, особенно в условиях ограниченных ресурсов. Например, алгоритм сортировки слиянием требует O(n) дополнительной памяти для хранения временных массивов, в то время как быстрая сортировка может работать с O(log n) дополнительной памятью, если реализована с использованием рекурсии.
### Что такое жадные алгоритмы? Приведите пример.
Жадные алгоритмы — это подход к решению задач, при котором на каждом шаге принимается локально оптимальное решение с надеждой, что оно приведет к глобально оптимальному решению. Этот метод часто используется в задачах, где важно минимизировать или максимизировать некоторую функцию. Примером может служить задача о рюкзаке с дробными предметами, где жадный алгоритм выбирает предметы на основе их ценности на единицу веса.
```php
///задача о рюкзаке
function fractionalKnapsack($weights, $values, $capacity) {
    $items = [];
    for ($i = 0; $i < count($values); $i++) {
        $items[] = ['value' => $values[$i], 'weight' => $weights[$i], 'ratio' => $values[$i] / $weights[$i]];
    }
    usort($items, function($a, $b) {
        return $b['ratio'] <=> $a['ratio'];
    });

    $totalValue = 0;
    foreach ($items as $item) {
        if ($capacity >= $item['weight']) {
            $capacity -= $item['weight'];
            $totalValue += $item['value'];
        } else {
            $totalValue += $item['ratio'] * $capacity;
            break;
        }
    }
    return $totalValue;
}

```
### Как работает алгоритм Дейкстры Дийкстры?
Алгоритм Дейкстры используется для нахождения кратчайшего пути от одной вершины до всех остальных в графе с неотрицательными весами рёбер. Он работает, начиная с начальной вершины и постепенно "расширяя" известные кратчайшие пути к соседним вершинам, обновляя их, если находится более короткий путь.
```php
function dijkstra($graph, $start) {
    $dist = [];
    $prev = [];
    $queue = [];

    foreach ($graph as $vertex => $edges) {
        $dist[$vertex] = INF;
        $prev[$vertex] = null;
        $queue[$vertex] = $dist[$vertex];
    }
    $dist[$start] = 0;

    while (!empty($queue)) {
        $minVertex = array_search(min($dist), $dist);
        unset($queue[$minVertex]);

        foreach ($graph[$minVertex] as $neighbor => $cost) {
            $alt = $dist[$minVertex] + $cost;
            if ($alt < $dist[$neighbor]) {
                $dist[$neighbor] = $alt;
                $prev[$neighbor] = $minVertex;
            }
        }
    }
    return $dist;
}
```

### Объясните, что такое рекурсия и дайте пример.
Рекурсия — это метод решения задач, при котором функция вызывает саму себя для решения подзадач. Рекурсивные алгоритмы часто имеют базовый случай, который останавливает рекурсию, и рекурсивный случай, который делит задачу на более простые части. Рекурсия используется в таких задачах, как вычисление факториала, обход деревьев и графов.
```php
function factorial($n) {
    if ($n <= 1) {
        return 1;
    }
    return $n * factorial($n - 1);
}
```
### Как работает алгоритм сортировки слиянием?
Сортировка слиянием — это алгоритм сортировки, который использует метод "разделяй и властвуй". Он делит массив на две половины, рекурсивно сортирует каждую половину и затем объединяет отсортированные половины в один отсортированный массив. Это обеспечивает стабильную сортировку с временной сложностью O(n log n).
```php
function mergeSort($array) {
    if (count($array) < 2) {
        return $array;
    }
    $mid = floor(count($array) / 2);
    $left = mergeSort(array_slice($array, 0, $mid));
    $right = mergeSort(array_slice($array, $mid));

    return merge($left, $right);
}

function merge($left, $right) {
    $result = [];
    while (count($left) > 0 && count($right) > 0) {
        if ($left[0] < $right[0]) {
            $result[] = array_shift($left);
        } else {
            $result[] = array_shift($right);
        }
    }
    return array_merge($result, $left, $right);
}
```
### Что такое динамическое программирование? Приведите пример задачи.
Динамическое программирование — это метод решения задач, который разбивает их на подзадачи и запоминает результаты, чтобы избежать повторного вычисления. Это особенно полезно для задач, которые могут быть разбиты на перекрывающиеся подзадачи, таких как задачи о рюкзаке, вычисление чисел Фибоначчи и задачи о максимальной подпоследовательности.
```php
function fibonacci($n) {
    $fib = [0, 1];
    for ($i = 2; $i <= $n; $i++) {
        $fib[$i] = $fib[$i - 1] + $fib[$i - 2];
    }
    return $fib[$n];
}
```
### Как работает алгоритм быстрой сортировки?
Быстрая сортировка — это алгоритм сортировки, который также использует метод "разделяй и властвуй". Он выбирает опорный элемент и разделяет массив на элементы, меньшие и большие опорного, а затем рекурсивно сортирует эти подмассивы. Средняя временная сложность составляет O(n log n), но в худшем случае может достигать O(n^2).
```php
function quickSort($array) {
    if (count($array) < 2) {
        return $array;
    }
    $pivot = $array[0];
    $left = array_filter(array_slice($array, 1), fn($x) => $x < $pivot);
    $right = array_filter(array_slice($array, 1), fn($x) => $x >= $pivot);
    return array_merge(quickSort($left), [$pivot], quickSort($right));
}
```
### Что такое поиск в глубину и поиск в ширину?
Поиск в глубину (DFS) и поиск в ширину (BFS) — это алгоритмы для обхода графов. DFS использует стек (рекурсию) для посещения узлов, углубляясь в граф до тех пор, пока не достигнет конца, а затем возвращается. BFS использует очередь для посещения узлов по уровням, гарантируя, что все узлы на одном уровне будут посещены перед переходом к следующему.
```php
///DFS
function dfs($graph, $node, &$visited) {
    if (!in_array($node, $visited)) {
        $visited[] = $node;
        foreach ($graph[$node] as $neighbor) {
            dfs($graph, $neighbor, $visited);
        }
    }
}

```
```php
///BFS
function bfs($graph, $start) {
    $visited = [];
    $queue = [$start];

    while (!empty($queue)) {
        $node = array_shift($queue);
        if (!in_array($node, $visited)) {
            $visited[] = $node;
            foreach ($graph[$node] as $neighbor) {
                $queue[] = $neighbor;
            }
        }
    }
    return $visited;
}
```
### Как работает алгоритм Краскала для нахождения минимального остовного дерева?
Алгоритм Краскала находит минимальное остовное дерево в графе, используя жадный подход. Он сортирует все рёбра по весу и добавляет их в остовное дерево, если они не создают цикл, пока не будут добавлены все вершины. Для этого часто используется структура данных "система непересекающихся множеств".
```php
function kruskal($vertices, $edges) {
    usort($edges, fn($a, $b) => $a[2] <=> $b[2]);
    $parent = [];
    foreach ($vertices as $vertex) {
        $parent[$vertex] = $vertex;
    }

    $result = [];
    foreach ($edges as $edge) {
        [$u, $v, $weight] = $edge;
        if (find($parent, $u) !== find($parent, $v)) {
            $result[] = $edge;
            union($parent, $u, $v);
        }
    }
    return $result;
}

function find(&$parent, $vertex) {
    if ($parent[$vertex] !== $vertex) {
        $parent[$vertex] = find($parent, $parent[$vertex]);
    }
    return $parent[$vertex];
}

function union(&$parent, $u, $v) {
    $parent[find($parent, $u)] = find($parent, $v);
}
```
### Объясните, что такое битовые операции и как их можно использовать в алгоритмах.
Битовые операции — это операции, которые выполняются над отдельными битами чисел. Они включают операции AND, OR, XOR, NOT, сдвиги влево и вправо. Битовые операции эффективны для работы с флагами, масками и оптимизацией алгоритмов, так как они выполняются быстрее, чем арифметические операции.
```php
$a = 5; // 0101 в двоичном
$b = 3; // 0011 в двоичном
$and = $a & $b; // 0001 (1)
$or = $a | $b; // 0111 (7)
$xor = $a ^ $b; // 0110 (6)
$not = ~$a; // 1010 (в зависимости от длины типа)
```
### Каковы основные методы поиска в массиве?
Существует несколько методов поиска в массиве, включая линейный и бинарный поиск. Линейный поиск проходит по каждому элементу массива, пока не найдет искомый, что делает его временную сложность O(n). Бинарный поиск, с другой стороны, требует, чтобы массив был отсортирован, и работает путем деления массива пополам, что дает временную сложность O(log n).
```php
function linearSearch($array, $target) {
    foreach ($array as $index => $value) {
        if ($value === $target) {
            return $index;
        }
    }
    return -1; // Не найден
}

function binarySearch($array, $target) {
    $low = 0;
    $high = count($array) - 1;
    while ($low <= $high) {
        $mid = floor(($low + $high) / 2);
        if ($array[$mid] === $target) {
            return $mid;
        } elseif ($array[$mid] < $target) {
            $low = $mid + 1;
        } else {
            $high = $mid - 1;
        }
    }
    return -1; // Не найден
}

```
### Что такое топологическая сортировка и когда она используется?
Топологическая сортировка — это упорядочение вершин ориентированного ациклического графа (DAG) так, что для каждого ребра (u, v) вершина u предшествует вершине v. Этот метод используется в задачах, где необходимо определить порядок выполнения задач, например, в компиляторах или планировании проектов.
```php
function topologicalSort($graph) {
    $inDegree = array_fill_keys(array_keys($graph), 0);
    foreach ($graph as $edges) {
        foreach ($edges as $neighbor) {
            $inDegree[$neighbor]++;
        }
    }

    $queue = array_filter(array_keys($inDegree), fn($v) => $inDegree[$v] === 0);
    $sorted = [];

    while (!empty($queue)) {
        $node = array_shift($queue);
        $sorted[] = $node;

        foreach ($graph[$node] as $neighbor) {
            $inDegree[$neighbor]--;
            if ($inDegree[$neighbor] === 0) {
                $queue[] = $neighbor;
            }
        }
    }
    return count($sorted) === count($graph) ? $sorted : []; // Проверка на наличие циклов
}
```

### Как реализовать алгоритм Флойда-Уоршелла?
Алгоритм Флойда-Уоршелла используется для нахождения кратчайших путей между всеми парами вершин в графе. Он работает, обновляя матрицу расстояний, проходя по всем вершинам и проверяя, может ли путь через одну вершину улучшить известное расстояние между двумя другими вершинами. Временная сложность составляет O(n^3).
```php
function floydWarshall($graph) {
    $dist = $graph;
    $n = count($graph);
    for ($k = 0; $k < $n; $k++) {
        for ($i = 0; $i < $n; $i++) {
            for ($j = 0; $j < $n; $j++) {
                if ($dist[$i][$j] > $dist[$i][$k] + $dist[$k][$j]) {
                    $dist[$i][$j] = $dist[$i][$k] + $dist[$k][$j];
                }
            }
        }
    }
    return $dist;
}
```

### Что такое сжатие пути в структуре данных "система непересекающихся множеств"?
Сжатие пути — это оптимизация в структуре данных "система непересекающихся множеств", которая помогает ускорить операции поиска. При выполнении операции find, каждый узел на пути к корню получает прямую ссылку на корень, что уменьшает высоту дерева и ускоряет будущие операции.
```php
class DisjointSet {
    private $parent = [];

    public function __construct($size) {
        for ($i = 0; $i < $size; $i++) {
            $this->parent[$i] = $i;
        }
    }

    public function find($x) {
        if ($this->parent[$x] !== $x) {
            $this->parent[$x] = $this->find($this->parent[$x]); // Сжатие пути
        }
        return $this->parent[$x];
    }

    public function union($x, $y) {
        $rootX = $this->find($x);
        $rootY = $this->find($y);
        if ($rootX !== $rootY) {
            $this->parent[$rootX] = $rootY;
        }
    }
}
```
### Как работает алгоритм Бойера-Мура для поиска подстроки?
Алгоритм Бойера-Мура — это эффективный алгоритм поиска подстроки, который использует информацию о символах в подстроке для пропуска ненужных сравнений. Он использует два правила: правило плохого символа, которое определяет, как далеко можно сдвинуть подстроку при несовпадении, и правило хорошего суффикса, которое помогает оптимизировать сдвиги.
```php
function boyerMoore($text, $pattern) {
    $m = strlen($pattern);
    $n = strlen($text);
    
    // Создаем таблицу сдвигов
    $badChar = array_fill(0, 256, -1);
    for ($i = 0; $i < $m; $i++) {
        $badChar[ord($pattern[$i])] = $i;
    }

    $s = 0; // s - смещение
    while ($s <= $n - $m) {
        $j = $m - 1;

        while ($j >= 0 && $pattern[$j] == $text[$s + $j]) {
            $j--;
        }

        if ($j < 0) {
            echo "Pattern found at index $s\n";
            $s += ($s + $m < $n) ? $m - $badChar[ord($text[$s + $m])] : 1;
        } else {
            $s += max(1, $j - $badChar[ord($text[$s + $j])]);
        }
    }
}
```
### Объясните, как работает алгоритм Левенштейна для вычисления расстояния редактирования.
Алгоритм Левенштейна вычисляет минимальное количество операций (вставка, удаление, замена), необходимых для преобразования одной строки в другую. Он использует динамическое программирование для создания матрицы, где каждая ячейка содержит минимальное расстояние редактирования для соответствующих подстрок.
```php
function levenshteinDistance($str1, $str2) {
    $lenStr1 = strlen($str1);
    $lenStr2 = strlen($str2);
    $matrix = array();

    for ($i = 0; $i <= $lenStr1; $i++) {
        $matrix[$i] = array_fill(0, $lenStr2 + 1, 0);
        $matrix[$i][0] = $i;
    }
    for ($j = 0; $j <= $lenStr2; $j++) {
        $matrix[0][$j] = $j;
    }

    for ($i = 1; $i <= $lenStr1; $i++) {
        for ($j = 1; $j <= $lenStr2; $j++) {
            $cost = ($str1[$i - 1] == $str2[$j - 1]) ? 0 : 1;
            $matrix[$i][$j] = min(
                $matrix[$i - 1][$j] + 1, // Удаление
                $matrix[$i][$j - 1] + 1, // Вставка
                $matrix[$i - 1][$j - 1] + $cost // Замена
            );
        }
    }
    return $matrix[$lenStr1][$lenStr2];
}
```
### Что такое жадные алгоритмы и когда они не работают?
Жадные алгоритмы выбирают локально оптимальные решения на каждом шаге, надеясь на достижение глобально оптимального результата. Они эффективны для задач, таких как задача о рюкзаке с дробными предметами или минимальное остовное дерево. Однако жадные алгоритмы не всегда приводят к оптимальному решению. Например, в задаче о рюкзаке с целыми предметами, жадный подход может привести к неэффективному решению.

Пример, когда жадные алгоритмы не работают: Если у вас есть предметы с весами и ценами, где не все комбинации приводят к оптимальному результату, жадный алгоритм может выбрать предметы, которые дают высокую ценность на единицу веса, но не обеспечивают максимальную общую ценность.
### Как реализовать алгоритм "Наименьшая сумма подмассива"?
Задача наименьшей суммы подмассива заключается в нахождении непрерывного подмассива, сумма элементов которого минимальна. Этот алгоритм может быть реализован с использованием метода "разделяй и властвуй" или простым перебором, но более эффективным способом будет использование одного прохода.
```php
function minSubArraySum($array) {
    $minSum = PHP_INT_MAX;
    $currentSum = 0;

    foreach ($array as $value) {
        $currentSum += $value;
        if ($currentSum < $minSum) {
            $minSum = $currentSum;
        }
        if ($currentSum > 0) {
            $currentSum = 0; // Сбрасываем, если сумма положительная
        }
    }
    return $minSum;
}
```

